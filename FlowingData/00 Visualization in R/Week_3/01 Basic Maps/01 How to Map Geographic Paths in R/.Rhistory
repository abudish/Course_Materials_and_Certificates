install.packages("benchmarkme")
install.packages("benchmarkme")
install.packages("benchmarkme")
install.packages("benchmarkme")
library(benchmarkme)
help(package = 'benchmarkme')
res <- benchmark_std(runs = 3)
plot(res)
upload_results(res)
get_cpu()
get_ram()
get_available_benchmarks()
?benchmark_io
res_io <- benchmark_io()
plot(res_io)
installed.packages('tidyverse')
install.packages("tidyverse")
ip <- as.data.frame(installed.packages()[,c(1,3:4)])
rownames(ip) <- NULL
ip <- ip[is.na(ip$Priority),1:2,drop=FALSE]
print(ip, row.names=FALSE)
get_cpu()
#########################################
# ---------------------------------------
# Functions
# ---------------------------------------
#########################################
# One simulation of the Monty Hall game
onerun <- function(.){ # Function of no arguments
doors <- 1:3
prize.door <- sample(doors, size=1)
choice <- sample(doors, size=1)
if (choice==prize.door) return(0) else return(1) # Always switch
}
# Many simulations of Monty Hall games
MontyHall <- function(runs, cores=detectCores()){
require(parallel)
# clusterApply() for Windows
if (Sys.info()[1] == "Windows"){
cl <- makeCluster(cores)
runtime <- system.time({
avg <- mean(unlist(clusterApply(cl=cl, x=1:runs, fun=onerun)))
})[3]
stopCluster(cl) # Don't forget to do this--I frequently do
# mclapply() for everybody else
} else {
runtime <- system.time({
avg <- mean(unlist(mclapply(X=1:runs, FUN=onerun, mc.cores=cores)))
})[3]
}
return(list(avg=avg, runtime=runtime))
}
#########################################
# ---------------------------------------
# Outputs
# ---------------------------------------
#########################################
run1 <- rbind(c(MontyHall(1e6, cores=1), "cores"=1))
run2 <- rbind(c(MontyHall(1e6, cores=4), "cores"=4))
run3 <- rbind(c(MontyHall(1e6, cores=8), "cores"=8))
rbind(run1, run2, run3)
install.packages("bigrquery")
install.packages("devtools")
library(devtools)
install_github("trestletech/shinyTable")
help(package = 'shinyTable')
library(shiny)
runApp(system.file("examples/01-simple", package = "shinyTable"))
?DT::renderDataTable()
library(shiny)
runExample("09_upload")
?fileInput
install.packages("ggiraph")
help(package = 'ggiraph')
help(packages = 'ggiraph')
help(package = 'ggiraph')
install.packages('rvg')
install.packages("ggiraph")
help(package = 'ggiraph')
library(shiny)
library(shinydashboard)
ui <- dashboardPage(
dashboardHeader(),
dashboardSidebar(
sidebarMenu(id = "sidebarmenu",
menuItem("A", tabName = "a",  icon = icon("group", lib="font-awesome")),
menuItem("B", tabName = "b", icon = icon("check-circle", lib = "font-awesome")),
conditionalPanel("input.sidebarmenu === 'b'",
sliderInput("b", "Under sidebarMenu", 1, 100, 50)
),
conditionalPanel("input.sidebarmenu === 'b'",
menuItem("C", tabName = "c", icon = icon("check-circle", lib = "font-awesome"))
)
)
),
dashboardBody()
)
server <- function(input, output) {}
shinyApp(ui, server)
# Load location data
costcos <- read.csv("http://projects.flowingdata.com/tut/data/costcos-geocoded.csv", sep=",")
head(costcos)
library(maps)
# Map of points
map(database="state", col="#cccccc")
symbols(costcos$Longitude, costcos$Latitude, bg="#e2373f", fg="#ffffff", lwd=0.5, circles=rep(1, length(costcos$Longitude)), inches=0.03, add=TRUE)
map(database="state", col="#cccccc")
costcos.o <- costcos[order(costcos$Zip.Code, decreasing=FALSE),]
lines(costcos.o$Longitude, costcos.o$Latitude, lwd=0.3, col="red")
points(costcos.o$Longitude, costcos.o$Latitude, pch=21, col="red", cex=0.2)
# Symbols plot
plot(costcos$Longitude, costcos$Latitude)
setwd("~/R_related/Course_Materials_and_Certificates/FlowingData/00 Visualization in R/Week_3/01 Basic Maps/01 How to Map Geographic Paths in R")
# Load data
routes <- read.csv("runkeeper-routes-sf.csv", stringsAsFactors=FALSE)
head(routes)
# Basic points plot
plot(routes$latitude, routes$longitude, type="n")
points(routes$latitude, routes$longitude, pch=20, cex=0.3)
# Basic lines plot
plot(routes$latitude, routes$longitude, type="n")
routeIds <- unique(routes$tempid)
for (i in 1:length(routeIds)) {
currRoute <- subset(routes, tempid==routeIds[i])
lines(currRoute$latitude, currRoute$longitude)
}
install.packages("mapproj")
help(package = 'mapproj')
#
# Use map projections
#
library(mapproj)
# Albers projection
locProj <- mapproject(routes$latitude, routes$longitude, "albers", par=c(37, 37.5))
routes$latproj <- locProj$x
routes$lonproj <- locProj$y
head(routes)
# Map the projected points
plot(routes$latproj, routes$lonproj, type="n", asp=1, axes=FALSE, xlab="", ylab="")
for (i in 1:length(routeIds)) {
currRoute <- subset(routes, tempid==routeIds[i])
lines(currRoute$latproj, currRoute$lonproj)
}
# Rectangular
locProj <- mapproject(routes$latitude, routes$longitude, "rectangular", par=38)
routes$latproj <- locProj$x
routes$lonproj <- locProj$y
# With transparency and thinner lines
par(mar=c(0,0,0,0))
plot(routes$latproj, routes$lonproj, type="n", asp=1, axes=FALSE, xlab="", ylab="")
for (i in 1:length(routeIds)) {
currRoute <- subset(routes, tempid==routeIds[i])
lines(currRoute$latproj, currRoute$lonproj, col="#00000020", lwd=0.4)
}
# Varied line width, consistent 20 transparency
par(mfrow=c(2,3))
for (m in 0:5) {
lineWidth <- 0.1 + 0.5 * m
plot(routes$latproj, routes$lonproj, type="n", asp=1, axes=FALSE, xlab="", ylab="")
for (i in 1:length(routeIds)) {
currRoute <- subset(routes, tempid==routeIds[i])
lines(currRoute$latproj, currRoute$lonproj, col="#00000020", lwd=lineWidth)
}
}
# Varied colors per route
library(scales)     # For transparency
pickColor <- function() {
# Pick a random color
i <- sample(1:657, 1)
theColor <- alpha(colors()[i], 0.3)
return(theColor)
}
par(mar=c(0,0,0,0))
plot(routes$latproj, routes$lonproj, type="n", asp=1, axes=FALSE, xlab="", ylab="")
for (i in 1:length(routeIds)) {
currRoute <- subset(routes, tempid==routeIds[i])
lines(currRoute$latproj, currRoute$lonproj, col=pickColor(), lwd=0.5)
}
par(mfrow=c(1,1))
par(mar=c(0,0,0,0))
plot(routes$latproj, routes$lonproj, type="n", asp=1, axes=FALSE, xlab="", ylab="")
for (i in 1:length(routeIds)) {
currRoute <- subset(routes, tempid==routeIds[i])
lines(currRoute$latproj, currRoute$lonproj, col=pickColor(), lwd=0.5)
}
#
# Introduce base map
#
detailMap <- function(bbox, thedata) {
basemap <- get_map(location=bbox, source='google', maptype="terrain", color="bw")
ggmap(basemap) + geom_path(aes(x=longitude, y=latitude, group=tempid), size=0.3, color="#570864", alpha=0.3, data=thedata)
}
sanfran <- c(-122.50476977783954, 37.70528090348771, -122.3619475122155, 37.83825794027055)
detailMap(sanfran, routes)
install.packages("ggmap")
library(ggmap)
#
# Introduce base map
#
detailMap <- function(bbox, thedata) {
basemap <- get_map(location=bbox, source='google', maptype="terrain", color="bw")
ggmap(basemap) + geom_path(aes(x=longitude, y=latitude, group=tempid), size=0.3, color="#570864", alpha=0.3, data=thedata)
}
sanfran <- c(-122.50476977783954, 37.70528090348771, -122.3619475122155, 37.83825794027055)
detailMap(sanfran, routes)
