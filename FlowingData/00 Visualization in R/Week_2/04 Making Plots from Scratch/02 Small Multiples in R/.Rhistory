install.packages("benchmarkme")
install.packages("benchmarkme")
install.packages("benchmarkme")
install.packages("benchmarkme")
library(benchmarkme)
help(package = 'benchmarkme')
res <- benchmark_std(runs = 3)
plot(res)
upload_results(res)
get_cpu()
get_ram()
get_available_benchmarks()
?benchmark_io
res_io <- benchmark_io()
plot(res_io)
installed.packages('tidyverse')
install.packages("tidyverse")
ip <- as.data.frame(installed.packages()[,c(1,3:4)])
rownames(ip) <- NULL
ip <- ip[is.na(ip$Priority),1:2,drop=FALSE]
print(ip, row.names=FALSE)
get_cpu()
#########################################
# ---------------------------------------
# Functions
# ---------------------------------------
#########################################
# One simulation of the Monty Hall game
onerun <- function(.){ # Function of no arguments
doors <- 1:3
prize.door <- sample(doors, size=1)
choice <- sample(doors, size=1)
if (choice==prize.door) return(0) else return(1) # Always switch
}
# Many simulations of Monty Hall games
MontyHall <- function(runs, cores=detectCores()){
require(parallel)
# clusterApply() for Windows
if (Sys.info()[1] == "Windows"){
cl <- makeCluster(cores)
runtime <- system.time({
avg <- mean(unlist(clusterApply(cl=cl, x=1:runs, fun=onerun)))
})[3]
stopCluster(cl) # Don't forget to do this--I frequently do
# mclapply() for everybody else
} else {
runtime <- system.time({
avg <- mean(unlist(mclapply(X=1:runs, FUN=onerun, mc.cores=cores)))
})[3]
}
return(list(avg=avg, runtime=runtime))
}
#########################################
# ---------------------------------------
# Outputs
# ---------------------------------------
#########################################
run1 <- rbind(c(MontyHall(1e6, cores=1), "cores"=1))
run2 <- rbind(c(MontyHall(1e6, cores=4), "cores"=4))
run3 <- rbind(c(MontyHall(1e6, cores=8), "cores"=8))
rbind(run1, run2, run3)
install.packages("bigrquery")
install.packages("devtools")
library(devtools)
install_github("trestletech/shinyTable")
help(package = 'shinyTable')
library(shiny)
runApp(system.file("examples/01-simple", package = "shinyTable"))
?DT::renderDataTable()
library(shiny)
runExample("09_upload")
?fileInput
install.packages("ggiraph")
help(package = 'ggiraph')
help(packages = 'ggiraph')
help(package = 'ggiraph')
install.packages('rvg')
install.packages("ggiraph")
help(package = 'ggiraph')
plot(0, 0, xlim=c(0, 100), ylim=c(0, 100), type="n", xlab=NA, ylab=NA)
plot.new()
plot.window(xlim=c(0, 100), ylim=c(0, 100))
ticks <- seq(0, 100, 20)
par(las=1, cex=0.8)
axis(1, at=ticks, labels=ticks, pos=0)
axis(2, at=ticks, labels=ticks, pos=0)
# Multiple plot windows.
par(mfrow=c(2,3), mar=c(4,3,3,2), las=1, cex=0.6)
for (i in 1:6) {
plot.new()
plot.window(xlim=c(0, 100), ylim=c(0, 100))
ticks <- seq(0, 100, 20)
axis(1, at=ticks, labels=ticks, pos=0)
axis(2, at=ticks, labels=ticks, pos=0)
}
# Setup grid.
par(mfrow=c(2,3), mar=c(4,3,3,2), las=1, cex=0.6)
# Fake data.
x.fakedata <- runif(20, 0, 100)
y.fakedata <- runif(20, 0, 100)
# Plot different kinds of points.
for (i in 1:6) {
plot.new()
plot.window(xlim=c(0, 100), ylim=c(0, 100))
ticks <- seq(0, 100, 20)
axis(1, at=ticks, labels=ticks, pos=0)
axis(2, at=ticks, labels=ticks, pos=0)
# Add symbols, shapes, and stuff.
points(x.fakedata, y.fakedata, pch=18+i)
}
# Draw circles.
symbols(x.fakedata, y.fakedata, circles=x.fakedata, add=TRUE, inches=0.25)
# Draw squares.
symbols(x.fakedata, y.fakedata, squares=x.fakedata, add=TRUE, inches=0.25)
# Draw circles.
symbols(x.fakedata, y.fakedata, circles=x.fakedata, add=F, inches=0.25)
# Draw squares.
symbols(x.fakedata, y.fakedata, squares=x.fakedata, add=F, inches=0.25)
plot.new()
plot.window(xlim=c(0, 100), ylim=c(0, 100))
ticks <- seq(0, 100, 20)
par(las=1, cex=0.8)
axis(1, at=ticks, labels=ticks, pos=0)
axis(2, at=ticks, labels=ticks, pos=0)
# Draw the octagon
x.oct <- c(40, 60, 80, 80, 60, 40, 20, 20, 40)
y.oct <- c(80, 80, 60, 40, 20, 20, 40, 60, 80)
polygon(x.oct, y.oct, col="#821122", border=NA)
# Draw the triangle.
x.tri <- c(50, 60, 40, 50)
y.tri <- c(60, 40, 40, 60)
polygon(x.tri, y.tri, col="#f0f0f0", border="#ffffff", lwd=4)
plot.new()
+     plot.window(xlim=c(0, 100), ylim=c(0, 100))
+     ticks <- seq(0, 100, 20)
+     axis(1, at=ticks, labels=ticks, pos=0)
+     axis(2, at=ticks, labels=ticks, pos=0)
# Draw lines and segments.
x.from <- seq(10, 90, by=10)
y.from <- seq(10, 90, by=10)
x.to <- seq(20, 100, by=10)
y.to <- seq(10, 90, by=10)
# Lines for continuous connections
lines(x.from, y.from)
# Multiple lines, not necessarily connected
segments(x.from, y.from, x.to, y.to)
segments(x.from, y.from, x.to, y.to, lty=2)
# New plot window with axes and ticks
plot.new()
plot.window(xlim=c(0, 100), ylim=c(0, 100))
ticks <- seq(0, 100, 20)
par(las=1, cex=0.8)
axis(1, at=ticks, labels=ticks, pos=0)
axis(2, at=ticks, labels=ticks, pos=0)
# Draw variable sized numbers based on x values
for (i in 1:length(x.fakedata)) {
thesize <- 4*x.fakedata[i]/100
thelabel <- round(x.fakedata[i])
text(x.fakedata[i], y.fakedata[i], thelabel, cex=thesize, col="#333333")
}
# Text outside plot margins.
mtext("x axis", side=1, font=2)
mtext("y axis", side=2, font=2)
par(mfrow=c(10, 3), xpd=NA, mar=c(2,0.5,2,0.5), lwd=0.5, cex=0.5)
for (i in 1:30) {
plot.new()
plot.window(xlim=c(0, 50), ylim=c(0, 1))
fakedata <- runif(50)
rect(0:49, 0, 1:50, fakedata, col="gray", border=NA)
segments(c(10, 40), c(2, 2), c(10, 40), c(-2, -2), col="black", lwd=0.7, lty=3)
mtext(i, side=3, adj=0, cex=0.5, font=2)
}
# Make sparklines with color.
par(mfrow=c(10, 3), xpd=NA, mar=c(2,0.5,2,0.5), lwd=0.5, cex=0.5)
colors <- c("#09c912", "#f40053", "#4ba9fd")
for (i in 1:30) {
plot.new()
plot.window(xlim=c(0, 50), ylim=c(0, 1))
fakedata <- runif(50)
colindex <- (i %% 3) + 1
rect(0:49, 0, 1:50, fakedata, border=NA, col=colors[colindex])
segments(c(10, 40), c(2, 2), c(10, 40), c(-2, -2), col="black", lwd=0.7, lty=3)
mtext(i, side=3, adj=0, cex=0.5, font=2)
}
setwd("~/R_related/Course_Materials_and_Certificates/FlowingData/00 Visualization in R/Week_2/04 Making Plots from Scratch/02 Small Multiples in R")
# Load data
causes <- read.csv("./data/12s0121-truncated.txt", sep="\t", header=TRUE)
View(causes)
# One bar plot
i <- 1
firstCause <- causes[i,2:12]
barplot(as.numeric(firstCause))
par(mfrow=c(1, 1))
# One bar plot
i <- 1
firstCause <- causes[i,2:12]
barplot(as.numeric(firstCause))
?par
# Bar plot for each cause
par(mfrow=c(10,9), mar=c(1,2,1,1))
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
barplot(as.numeric(currCause))
}
# Make bar plots more readable.
par(mfrow=c(12,8), mar=c(1,5,3,1))
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
barplot(as.numeric(currCause), main=causes[i,1], cex.main=0.8, cex.axis=0.7, border="white", space=0)
}
# Make bar plots more readable.
par(mfrow=c(12,8), mar=c(1,5,3,1))
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
barplot(as.numeric(currCause), main=causes[i,1], cex.main=0.8, cex.axis=0.7, border="white", space=0)
}
# Mess around with axes
par(mfrow=c(12,8), mar=c(1,5,3,1))
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
# Draw bar plot with no axes
barplot(as.numeric(currCause), main=causes[i,1], cex.main=0.8, cex.axis=0.7, border="white", col="#e26b43", space=0, axes=FALSE)
# Draw custom axes
axis(side=1, at=c(0,11), labels=FALSE)
axis(side=2, at=c(0,max(currCause)), cex=0.7)
}
# Compare counts
par(mfrow=c(12,8), mar=c(1,5,3,1))
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
# Draw bar plot with no axes, same vertical scale
barplot(as.numeric(currCause), main=causes[i,1], cex.main=0.8, cex.axis=0.7, border="white", col="#e26b43", space=0, axes=FALSE, ylim=c(0,120000))
# Draw custom axes
axis(side=1, at=c(0,11), labels=FALSE)
axis(side=2, at=c(0,max(currCause)), cex=0.7)
}
# Highlighting
par(mfrow=c(12,8), mar=c(1,5,3,1))
for (i in 1:length(causes[,1])) {
currCause <- as.numeric( causes[i,2:12] )
# Find age group with highest count
maxCnt <- max(currCause)
groupNum <- which(currCause == maxCnt)
# Color based on max age group
if (groupNum < 5) {
barColor <- "#e26b43"    # Orange-red
} else {
barColor <- "#cccccc"    # Gray
}
# Draw the bar plot
barplot(currCause, main=causes[i,1], cex.main=0.8, cex.axis=0.7, border="white", col=barColor, space=0, axes=FALSE)
axis(side=1, at=c(0,11), labels=FALSE)
axis(side=2, at=c(0,max(currCause)), cex=0.8)
}
# Custom chart (just one)
i <- 1
firstCause <- as.numeric( causes[i,2:12] )
maxCnt <- max(firstCause)
yOffset <- (maxCnt - firstCause) / 2
plot(0, 0, type="n", xlim=c(0,11), ylim=c(0, max(firstCause)), xlab="", ylab="", axes=FALSE, bty="n")
rect(0:10, yOffset, 1:11, firstCause+yOffset, col="#cccccc", border="white")
# Now do it for all causes
par(mfrow=c(12,8), mar=c(1,3,3,1))
for (i in 1:length(causes[,1])) {
currCause <- as.numeric( causes[i,2:12] )
# Find age group with highest count
maxCnt <- max(currCause)
# Draw the custom chart
yOffset <- (maxCnt - currCause) / 2
plot(0, 0, type="n", xlim=c(0,11), ylim=c(0, max(currCause)), xlab="", ylab="", axes=FALSE, bty="n", cex.main=0.8, main=causes[i,1])
rect(0:10, yOffset, 1:11, currCause+yOffset, col="#e26b43", border="white")
}
# Try a different plot type for kicks
par(mfrow=c(12,8), mar=c(1,3,3,1))
source("areaGraph.R")
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
areaGraph(currCause)
}
# Type 0: stacked area, 1: themeriver, 2: streamgraph
areaGraph <- function(thedata, type=2, smooth=TRUE) {
# Color palette
nColors <- 10
pal <- colorRampPalette(c("#0f7fb4", "#e2e2e2"))
colors <- pal(nColors)
# Sort the data
if (type == 0) {					# Stacked area
# Greatest to least weights
sortedData <- thedata[order(rowSums(thedata), decreasing=TRUE),]
} else if (type ==1 || type == 2) {				# Themeriver or streamgraph
# Initialize sorted data frame
sortedData <- thedata[1,]
weights <- rowSums(thedata)
topWeight <- weights[1]
bottomWeight <- weights[1]
if (length(thedata[,1]) > 1) {
# Commence sorting. Apparently not most efficient way, but whatever.
for (i in 2:length(thedata[,1])) {
if (topWeight > bottomWeight) {
sortedData <- rbind(sortedData, thedata[i,])
} else {
sortedData <- rbind(thedata[i,], sortedData)
bototmWeight <- bottomWeight + weights[i]
}
}
}
}
# Smooth the data
if (smooth) {
nPoints <- 200
# Initialize smoothed data. Note: Probably a better way to do this, but it works. [NY]
firstRow <- spline(1:length(sortedData[1,]), sortedData[1,], nPoints)$y
firstRow <- sapply(firstRow, zeroNegatives)
smoothData <- data.frame( rbind(firstRow, rep(0, length(firstRow))) )
smoothData <- smoothData[1,]
# Smooth the rest of the data using spline().
if (length(sortedData[,1]) > 1) {
for (i in 2:length(sortedData[,1])) {
newRow <- spline(1:length(sortedData[i,]), sortedData[i,], nPoints)$y
newRow <- sapply(newRow, zeroNegatives)
smoothData <- rbind(smoothData, newRow)
}
}
finalData <- smoothData
} else {
finalData <- sortedData
}
# Totals for each vertical slice
totals <- colSums(finalData)
# Determine baseline offset
if (type == 0) {
yOffset <- rep(0, length(totals))
} else if (type == 1) {
yOffset <- -totals / 2
} else if (type == 2) {
n <- length(finalData[,1])
i <- 1:length(finalData[,1])
parts <- (n - i + 1) * finalData
theSums <- colSums(parts)
yOffset <- -theSums / (n + 1)
}
# Axis upper and lower bounds
yLower <- min(yOffset)
yUpper <- max(yOffset + totals)
# Max, min, and span of weights for each layer
maxRow <- max(rowSums(finalData))
minRow <- min(rowSums(finalData))
rowSpan <- if ( (maxRow - minRow) > 0 ) { maxRow - minRow } else { 1 }
# Make the graph.
par(las=1, cex=0.6, bty="n")
plot(0, 0, type="n", xlim=c(1, length(finalData[1,])), ylim=c(yLower, yUpper), xlab=NA, ylab=NA)
for (i in 1:length(finalData[,1])) {
colIndex <- floor( (nColors-2) * ( (maxRow - sum(finalData[i,])) / rowSpan ) ) + 1
polygon(c(1:length(finalData[i,]), length(finalData[i,]):1), c(finalData[i,] + yOffset, rev(yOffset)), col=colors[colIndex], border="#ffffff", lwd=0.2)
# Move up to next layer.
yOffset <- yOffset + finalData[i,]
}
}
# Helper function to convert negative values to zero
zeroNegatives <- function(x) {
if (x < 0) { return(0) }
else { return(x) }
}
# Try a different plot type for kicks
par(mfrow=c(12,8), mar=c(1,3,3,1))
source("areaGraph.R")
for (i in 1:length(causes[,1])) {
currCause <- causes[i,2:12]
areaGraph(currCause)
}
